# SPDX-FileCopyrightText: 2022 Renaissance Computing Institute. All rights reserved.
#
# SPDX-License-Identifier: GPL-3.0-or-later
# SPDX-License-Identifier: LicenseRef-RENCI
# SPDX-License-Identifier: MIT

---
apiVersion: v1
kind: ConfigMap
metadata:
  name: "{{- include "asgs-postgres.fullname" . }}-scripts"
data:
  loaddb.sh: |-
    #!/bin/bash
    apt-get -yq update
    apt-get -yq install zip

    BCKP_FILE_1=/data/{{ .Values.sqlFile1 }}
    BCKP_FILE_2=/data/{{ .Values.sqlFile2 }}
    BCKP_FILE_3=/data/{{ .Values.sqlFile3 }}
    BCKP_FILE_4=/data/{{ .Values.sqlFile4 }}

    until pg_isready ; do
        echo "postgres not ready";
        sleep 10
    done

    cd /data

    unzip -P {{ .Values.zipPassword }} -j {{ .Values.zipFileName }}

    #until false ; do
    #    sleep 30
    #done

    # restore the roles without the postgres password. psql us used here because it is text format
    psql -U {{ .Values.adminuser }} < $BCKP_FILE_1

    # restore the database. pg_restore is used here because it is a compressed backup
    pg_restore -d postgres --clean --create $BCKP_FILE_2

    pg_restore -d postgres --clean --create $BCKP_FILE_3

    pg_restore -d postgres --clean --create $BCKP_FILE_4

    # this is truly a hack. pg_restore returns a count of warnings,
    # in this case a warning stating that the "public schema already exists".
    # this ends up creating issues in k8s. note in this case the public schema
    # existing is due to the base postgres image used for postgis.
    exit 0

  dumpDatabase.sh: |-
    #
    # backs up certain important databases.
    #
    # should be run as a cronjob nightly at midnight (local), e.g.
    # 0 21 * * * postgres /storage/backups.sh
    BASE_DIR=/data
    DUMPS_DIR=$BASE_DIR/db-backups

    if [ -e $LOG_PATH/export.log ]; then
        rm $LOG_PATH/export.log
    fi

    date >> $LOG_PATH/export.log

    for i in `psql -h $ASGS_DB_HOST -c "SELECT datname FROM pg_database where datname in ('apsviz', 'adcirc_obs', 'asgs_dashboard')" | head -n -2 | tail -n +3`; do
        for j in {8..1}; do
            DUMP_FILE=$DUMPS_DIR/$i.dump.$j
            NEW_DUMP_FILE=$DUMPS_DIR/$i.dump.$(( j + 1 ))
            if [ -e $DUMP_FILE ]; then
                echo "mv $DUMP_FILE $NEW_DUMP_FILE" >> $LOG_PATH/export.log
                mv $DUMP_FILE $NEW_DUMP_FILE
            fi
        done
    done

    for i in `psql -h $ASGS_DB_HOST -c "SELECT datname FROM pg_database where datname in ('apsviz', 'adcirc_obs', 'asgs_dashboard')" | head -n -2 | tail -n +3`; do
        if [ -e $DUMPS_DIR/$i.dump.8 ]; then
            echo "removing $DUMPS_DIR/$i.dump.8" >> $LOG_PATH/export.log
            rm $DUMPS_DIR/$i.dump.8
        fi
        echo "dumping...$DUMPS_DIR/$i.dump.1" >> $LOG_PATH/export.log
        date >> $LOG_PATH/export.log
        pg_dump -h $ASGS_DB_HOST -d $i -Fc -f $DUMPS_DIR/$i.dump.1
        date >> $LOG_PATH/export.log
    done